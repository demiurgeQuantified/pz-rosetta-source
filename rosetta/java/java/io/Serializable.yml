version: '1.1'
languages:
  java:
    packages:
      java.io:
        Serializable:
          extends: java.lang.Object
          modifiers:
          - public
          - abstract
          notes: "Serializability of a class is enabled by the class implementing\
            \ the\n java.io.Serializable interface.\n\n Warning: Deserialization of\
            \ untrusted data is inherently dangerous\n and should be avoided. Untrusted\
            \ data should be carefully validated according to the\n \"Serialization\
            \ and Deserialization\" section of the\n Secure Coding Guidelines for\
            \ Java SE.\n Serialization Filtering describes best\n practices for defensive\
            \ use of serial filters.\n \n\n Classes that do not implement this\n interface\
            \ will not have any of their state serialized or\n deserialized.  All\
            \ subtypes of a serializable class are themselves\n serializable.  The\
            \ serialization interface has no methods or fields\n and serves only to\
            \ identify the semantics of being serializable. \n\n It is possible for\
            \ subtypes of non-serializable classes to be serialized\n and deserialized.\
            \ During serialization, no data will be written for the\n fields of non-serializable\
            \ superclasses. During deserialization, the fields of non-serializable\n\
            \ superclasses will be initialized using the no-arg constructor of the\
            \ first (bottommost)\n non-serializable superclass. This constructor must\
            \ be accessible to the subclass that is being\n deserialized. It is an\
            \ error to declare a class Serializable if this is not\n the case; the\
            \ error will be detected at runtime. A serializable subtype may\n assume\
            \ responsibility for saving and restoring the state of a non-serializable\n\
            \ supertype's public, protected, and (if accessible) package-access fields.\
            \ See\n the \n Java Object Serialization Specification, section 3.1, for\n\
            \ a detailed specification of the deserialization process, including handling\
            \ of\n serializable and non-serializable classes. \n\n When traversing\
            \ a graph, an object may be encountered that does not\n support the Serializable\
            \ interface. In this case the\n NotSerializableException will be thrown\
            \ and will identify the class\n of the non-serializable object. \n\n Classes\
            \ that require special handling during the serialization and\n deserialization\
            \ process must implement special methods with these exact\n signatures:\n\
            \n \n private void writeObject(java.io.ObjectOutputStream out)\n     throws\
            \ IOException\n private void readObject(java.io.ObjectInputStream in)\n\
            \     throws IOException, ClassNotFoundException;\n private void readObjectNoData()\n\
            \     throws ObjectStreamException;\n \n\n The writeObject method is responsible\
            \ for writing the state of the\n object for its particular class so that\
            \ the corresponding\n readObject method can restore it.  The default mechanism\
            \ for saving\n the Object's fields can be invoked by calling\n out.defaultWriteObject.\
            \ The method does not need to concern\n itself with the state belonging\
            \ to its superclasses or subclasses.\n State is saved by writing the individual\
            \ fields to the\n ObjectOutputStream using the writeObject method or by\
            \ using the\n methods for primitive data types supported by DataOutput.\n\
            \n The readObject method is responsible for reading from the stream and\n\
            \ restoring the classes fields. It may call in.defaultReadObject to invoke\n\
            \ the default mechanism for restoring the object's non-static and\n non-transient\
            \ fields.  The defaultReadObject method uses information in\n the stream\
            \ to assign the fields of the object saved in the stream with the\n correspondingly\
            \ named fields in the current object.  This handles the case\n when the\
            \ class has evolved to add new fields. The method does not need to\n concern\
            \ itself with the state belonging to its superclasses or subclasses.\n\
            \ State is restored by reading data from the ObjectInputStream for\n the\
            \ individual fields and making assignments to the appropriate fields\n\
            \ of the object. Reading primitive data types is supported by DataInput.\n\
            \n The readObjectNoData method is responsible for initializing the state\
            \ of\n the object for its particular class in the event that the serialization\n\
            \ stream does not list the given class as a superclass of the object being\n\
            \ deserialized.  This may occur in cases where the receiving party uses\
            \ a\n different version of the deserialized instance's class than the\
            \ sending\n party, and the receiver's version extends classes that are\
            \ not extended by\n the sender's version.  This may also occur if the\
            \ serialization stream has\n been tampered; hence, readObjectNoData is\
            \ useful for initializing\n deserialized objects properly despite a \"\
            hostile\" or incomplete source\n stream.\n\n Serializable classes that\
            \ need to designate an alternative object to be\n used when writing an\
            \ object to the stream should implement this\n special method with the\
            \ exact signature:\n\n \n ANY-ACCESS-MODIFIER Object writeReplace() throws\
            \ ObjectStreamException;\n \n\n This writeReplace method is invoked by\
            \ serialization if the method\n exists and it would be accessible from\
            \ a method defined within the\n class of the object being serialized.\
            \ Thus, the method can have private,\n protected and package-private access.\
            \ Subclass access to this method\n follows java accessibility rules. \n\
            \n Classes that need to designate a replacement when an instance of it\n\
            \ is read from the stream should implement this special method with the\n\
            \ exact signature.\n\n \n ANY-ACCESS-MODIFIER Object readResolve() throws\
            \ ObjectStreamException;\n \n\n This readResolve method follows the same\
            \ invocation rules and\n accessibility rules as writeReplace.\n\n Enum\
            \ types are all serializable and receive treatment defined by\n the \n\
            \ Java Object Serialization Specification during\n serialization and deserialization.\
            \ Any declarations of the special\n handling methods discussed above are\
            \ ignored for enum types.\n\n Record classes can implement Serializable\
            \ and receive treatment defined\n by the \n Java Object Serialization\
            \ Specification, Section 1.13,\n \"Serialization of Records\". Any declarations\
            \ of the special\n handling methods discussed above are ignored for record\
            \ types.\n\n The serialization runtime associates with each serializable\
            \ class a version\n number, called a serialVersionUID, which is used during\
            \ deserialization to\n verify that the sender and receiver of a serialized\
            \ object have loaded\n classes for that object that are compatible with\
            \ respect to serialization.\n If the receiver has loaded a class for the\
            \ object that has a different\n serialVersionUID than that of the corresponding\
            \ sender's class, then\n deserialization will result in an InvalidClassException.\
            \  A\n serializable class can declare its own serialVersionUID explicitly\
            \ by\n declaring a field named \"serialVersionUID\" that must be static,\n\
            \ final, and of type long:\n\n \n ANY-ACCESS-MODIFIER static final long\
            \ serialVersionUID = 42L;\n \n\n If a serializable class does not explicitly\
            \ declare a serialVersionUID, then\n the serialization runtime will calculate\
            \ a default serialVersionUID value\n for that class based on various aspects\
            \ of the class, as described in the\n Java Object Serialization\n Specification.\
            \ This specification defines the\n serialVersionUID of an enum type to\
            \ be 0L. However, it is strongly\n recommended that all serializable classes\
            \ other than enum types explicitly declare\n serialVersionUID values,\
            \ since the default serialVersionUID computation is\n highly sensitive\
            \ to class details that may vary depending on compiler\n implementations,\
            \ and can thus result in unexpected\n InvalidClassExceptions during deserialization.\
            \  Therefore, to\n guarantee a consistent serialVersionUID value across\
            \ different java compiler\n implementations, a serializable class must\
            \ declare an explicit\n serialVersionUID value.  It is also strongly advised\
            \ that explicit\n serialVersionUID declarations use the private modifier\
            \ where\n possible, since such declarations apply only to the immediately\
            \ declaring\n class--serialVersionUID fields are not useful as inherited\
            \ members. Array\n classes cannot declare an explicit serialVersionUID,\
            \ so they always have\n the default computed value, but the requirement\
            \ for matching\n serialVersionUID values is waived for array classes."
