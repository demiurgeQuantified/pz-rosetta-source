version: '1.1'
languages:
  java:
    packages:
      java.util:
        Collection:
          extends: java.lang.Object
          modifiers:
          - public
          - abstract
          notes: "The root interface in the collection hierarchy.  A collection\n\
            \ represents a group of objects, known as its elements.  Some\n collections\
            \ allow duplicate elements and others do not.  Some are ordered\n and\
            \ others unordered.  The JDK does not provide any direct\n implementations\
            \ of this interface: it provides implementations of more\n specific subinterfaces\
            \ like Set and List.  This interface\n is typically used to pass collections\
            \ around and manipulate them where\n maximum generality is desired.\n\n\
            \ Bags or multisets (unordered collections that may contain\n duplicate\
            \ elements) should implement this interface directly.\n\n All general-purpose\
            \ Collection implementation classes (which\n typically implement Collection\
            \ indirectly through one of its\n subinterfaces) should provide two \"\
            standard\" constructors: a void (no\n arguments) constructor, which creates\
            \ an empty collection, and a\n constructor with a single argument of type\
            \ Collection, which\n creates a new collection with the same elements\
            \ as its argument.  In\n effect, the latter constructor allows the user\
            \ to copy any collection,\n producing an equivalent collection of the\
            \ desired implementation type.\n There is no way to enforce this convention\
            \ (as interfaces cannot contain\n constructors) but all of the general-purpose\
            \ Collection\n implementations in the Java platform libraries comply.\n\
            \n Certain methods are specified to be\n optional. If a collection implementation\
            \ doesn't implement a\n particular operation, it should define the corresponding\
            \ method to throw\n UnsupportedOperationException. Such methods are marked\
            \ \"optional\n operation\" in method specifications of the collections\
            \ interfaces.\n\n Some collection implementations\n have restrictions\
            \ on the elements that they may contain.\n For example, some implementations\
            \ prohibit null elements,\n and some have restrictions on the types of\
            \ their elements.  Attempting to\n add an ineligible element throws an\
            \ unchecked exception, typically\n NullPointerException or ClassCastException.\
            \  Attempting\n to query the presence of an ineligible element may throw\
            \ an exception,\n or it may simply return false; some implementations\
            \ will exhibit the former\n behavior and some will exhibit the latter.\
            \  More generally, attempting an\n operation on an ineligible element\
            \ whose completion would not result in\n the insertion of an ineligible\
            \ element into the collection may throw an\n exception or it may succeed,\
            \ at the option of the implementation.\n Such exceptions are marked as\
            \ \"optional\" in the specification for this\n interface.\n\n It is up\
            \ to each collection to determine its own synchronization\n policy.  In\
            \ the absence of a stronger guarantee by the\n implementation, undefined\
            \ behavior may result from the invocation\n of any method on a collection\
            \ that is being mutated by another\n thread; this includes direct invocations,\
            \ passing the collection to\n a method that might perform invocations,\
            \ and using an existing\n iterator to examine the collection.\n\n Many\
            \ methods in Collections Framework interfaces are defined in\n terms of\
            \ the equals method.  For example,\n the specification for the contains(Object\
            \ o)\n method says: \"returns true if and only if this collection\n contains\
            \ at least one element e such that\n (o==null ? e==null : o.equals(e)).\"\
            \  This specification should\n not be construed to imply that invoking\
            \ Collection.contains\n with a non-null argument o will cause o.equals(e)\
            \ to be\n invoked for any element e.  Implementations are free to implement\n\
            \ optimizations whereby the equals invocation is avoided, for\n example,\
            \ by first comparing the hash codes of the two elements.  (The\n Object.hashCode()\
            \ specification guarantees that two objects with\n unequal hash codes\
            \ cannot be equal.)  More generally, implementations of\n the various\
            \ Collections Framework interfaces are free to take advantage of\n the\
            \ specified behavior of underlying Object methods wherever the\n implementor\
            \ deems it appropriate.\n\n Some collection operations which perform recursive\
            \ traversal of the\n collection may fail with an exception for self-referential\
            \ instances where\n the collection directly or indirectly contains itself.\
            \ This includes the\n clone(), equals(), hashCode() and toString()\n methods.\
            \ Implementations may optionally handle the self-referential scenario,\n\
            \ however most current implementations do not do so.\n\n View Collections\n\
            \n Most collections manage storage for elements they contain. By contrast,\
            \ view\n collections themselves do not store elements, but instead they\
            \ rely on a\n backing collection to store the actual elements. Operations\
            \ that are not handled\n by the view collection itself are delegated to\
            \ the backing collection. Examples of\n view collections include the wrapper\
            \ collections returned by methods such as\n Collections.checkedCollection,\n\
            \ Collections.synchronizedCollection, and\n Collections.unmodifiableCollection.\n\
            \ Other examples of view collections include collections that provide\
            \ a\n different representation of the same elements, for example, as\n\
            \ provided by List.subList,\n NavigableSet.subSet, or\n Map.entrySet.\n\
            \ Any changes made to the backing collection are visible in the view collection.\n\
            \ Correspondingly, any changes made to the view collection &mdash; if\
            \ changes\n are permitted &mdash; are written through to the backing collection.\n\
            \ Although they technically aren't collections, instances of\n Iterator\
            \ and ListIterator can also allow modifications\n to be written through\
            \ to the backing collection, and in some cases,\n modifications to the\
            \ backing collection will be visible to the Iterator\n during iteration.\n\
            \n Unmodifiable Collections\n\n Certain methods of this interface are\
            \ considered \"destructive\" and are called\n \"mutator\" methods in that\
            \ they modify the group of objects contained within\n the collection on\
            \ which they operate. They can be specified to throw\n UnsupportedOperationException\
            \ if this collection implementation\n does not support the operation.\
            \ Such methods should (but are not required\n to) throw an UnsupportedOperationException\
            \ if the invocation would\n have no effect on the collection. For example,\
            \ consider a collection that\n does not support the add operation. What\
            \ will happen if the\n addAll method is invoked on this collection, with\
            \ an empty\n collection as the argument? The addition of zero elements\
            \ has no effect,\n so it is permissible for this collection simply to\
            \ do nothing and not to throw\n an exception. However, it is recommended\
            \ that such cases throw an exception\n unconditionally, as throwing only\
            \ in certain cases can lead to\n programming errors.\n\n An unmodifiable\
            \ collection is a collection, all of whose\n mutator methods (as defined\
            \ above) are specified to throw\n UnsupportedOperationException. Such\
            \ a collection thus cannot be\n modified by calling any methods on it.\
            \ For a collection to be properly\n unmodifiable, any view collections\
            \ derived from it must also be unmodifiable.\n For example, if a List\
            \ is unmodifiable, the List returned by\n List.subList is also unmodifiable.\n\
            \n An unmodifiable collection is not necessarily immutable. If the\n contained\
            \ elements are mutable, the entire collection is clearly\n mutable, even\
            \ though it might be unmodifiable. For example, consider\n two unmodifiable\
            \ lists containing mutable elements. The result of calling\n list1.equals(list2)\
            \ might differ from one call to the next if\n the elements had been mutated,\
            \ even though both lists are unmodifiable.\n However, if an unmodifiable\
            \ collection contains all immutable elements,\n it can be considered effectively\
            \ immutable.\n\n Unmodifiable View Collections\n\n An unmodifiable view\
            \ collection is a collection that is unmodifiable\n and that is also a\
            \ view onto a backing collection. Its mutator methods throw\n UnsupportedOperationException,\
            \ as described above, while\n reading and querying methods are delegated\
            \ to the backing collection.\n The effect is to provide read-only access\
            \ to the backing collection.\n This is useful for a component to provide\
            \ users with read access to\n an internal collection, while preventing\
            \ them from modifying such\n collections unexpectedly. Examples of unmodifiable\
            \ view collections\n are those returned by the\n Collections.unmodifiableCollection,\n\
            \ Collections.unmodifiableList, and\n related methods.\n\n Note that changes\
            \ to the backing collection might still be possible,\n and if they occur,\
            \ they are visible through the unmodifiable view. Thus,\n an unmodifiable\
            \ view collection is not necessarily immutable. However,\n if the backing\
            \ collection of an unmodifiable view is effectively immutable,\n or if\
            \ the only reference to the backing collection is through an\n unmodifiable\
            \ view, the view can be considered effectively immutable.\n\n Serializability\
            \ of Collections\n\n Serializability of collections is optional. As such,\
            \ none of the collections\n interfaces are declared to implement the Serializable\
            \ interface.\n However, serializability is regarded as being generally\
            \ useful, so most collection\n implementations are serializable.\n\n The\
            \ collection implementations that are public classes (such as ArrayList\n\
            \ or HashMap) are declared to implement the Serializable interface if\
            \ they\n are in fact serializable. Some collections implementations are\
            \ not public classes,\n such as the unmodifiable collections. In such\
            \ cases, the\n serializability of such collections is described in the\
            \ specification of the method\n that creates them, or in some other suitable\
            \ place. In cases where the serializability\n of a collection is not specified,\
            \ there is no guarantee about the serializability of such\n collections.\
            \ In particular, many view collections are not serializable.\n\n A collection\
            \ implementation that implements the Serializable interface cannot\n be\
            \ guaranteed to be serializable. The reason is that in general, collections\n\
            \ contain elements of other types, and it is not possible to determine\
            \ statically\n whether instances of some element type are actually serializable.\
            \ For example, consider\n a serializable Collection<E>, where E does not\
            \ implement the\n Serializable interface. The collection may be serializable,\
            \ if it contains only\n elements of some serializable subtype of E, or\
            \ if it is empty. Collections are\n thus said to be conditionally serializable,\
            \ as the serializability of the collection\n as a whole depends on whether\
            \ the collection itself is serializable and on whether all\n contained\
            \ elements are also serializable.\n\n An additional case occurs with instances\
            \ of SortedSet and SortedMap.\n These collections can be created with\
            \ a Comparator that imposes an ordering on\n the set elements or map keys.\
            \ Such a collection is serializable only if the provided\n Comparator\
            \ is also serializable.\n\n This interface is a member of the\n \n Java\
            \ Collections Framework."
          methods:
          - name: add
            modifiers:
            - public
            - abstract
            parameters:
            - name: arg0
              type:
                basic: E
                full: E
            return:
              type:
                basic: boolean
                full: boolean
          - name: addAll
            modifiers:
            - public
            - abstract
            parameters:
            - name: arg0
              type:
                basic: Collection
                full: java.util.Collection<? extends E>
            return:
              type:
                basic: boolean
                full: boolean
          - name: clear
            modifiers:
            - public
            - abstract
            return:
              type:
                basic: void
                full: void
          - name: contains
            modifiers:
            - public
            - abstract
            parameters:
            - name: arg0
              type:
                basic: Object
                full: java.lang.Object
            return:
              type:
                basic: boolean
                full: boolean
          - name: containsAll
            modifiers:
            - public
            - abstract
            parameters:
            - name: arg0
              type:
                basic: Collection
                full: java.util.Collection<?>
            return:
              type:
                basic: boolean
                full: boolean
          - name: equals
            modifiers:
            - public
            - abstract
            parameters:
            - name: arg0
              type:
                basic: Object
                full: java.lang.Object
            return:
              type:
                basic: boolean
                full: boolean
          - name: hashCode
            modifiers:
            - public
            - abstract
            return:
              type:
                basic: int
                full: int
          - name: isEmpty
            modifiers:
            - public
            - abstract
            return:
              type:
                basic: boolean
                full: boolean
          - name: iterator
            modifiers:
            - public
            - abstract
            return:
              type:
                basic: Iterator
                full: java.util.Iterator<E>
          - name: parallelStream
            modifiers:
            - public
            return:
              type:
                basic: Stream
                full: java.util.stream.Stream<E>
          - name: remove
            modifiers:
            - public
            - abstract
            parameters:
            - name: arg0
              type:
                basic: Object
                full: java.lang.Object
            return:
              type:
                basic: boolean
                full: boolean
          - name: removeAll
            modifiers:
            - public
            - abstract
            parameters:
            - name: arg0
              type:
                basic: Collection
                full: java.util.Collection<?>
            return:
              type:
                basic: boolean
                full: boolean
          - name: removeIf
            modifiers:
            - public
            parameters:
            - name: arg0
              type:
                basic: Predicate
                full: java.util.function.Predicate<? super E>
            return:
              type:
                basic: boolean
                full: boolean
          - name: retainAll
            modifiers:
            - public
            - abstract
            parameters:
            - name: arg0
              type:
                basic: Collection
                full: java.util.Collection<?>
            return:
              type:
                basic: boolean
                full: boolean
          - name: size
            modifiers:
            - public
            - abstract
            return:
              type:
                basic: int
                full: int
          - name: spliterator
            modifiers:
            - public
            return:
              type:
                basic: Spliterator
                full: java.util.Spliterator<E>
          - name: stream
            modifiers:
            - public
            return:
              type:
                basic: Stream
                full: java.util.stream.Stream<E>
          - name: toArray
            modifiers:
            - public
            - abstract
            return:
              type:
                basic: Object
                full: java.lang.Object[]
          - name: toArray
            modifiers:
            - public
            - abstract
            parameters:
            - name: arg0
              type:
                basic: T
                full: T[]
            return:
              type:
                basic: T
                full: T[]
          - name: toArray
            modifiers:
            - public
            parameters:
            - name: arg0
              type:
                basic: IntFunction
                full: java.util.function.IntFunction<T[]>
            return:
              type:
                basic: T
                full: T[]
