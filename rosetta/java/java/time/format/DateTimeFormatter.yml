version: '1.1'
languages:
  java:
    packages:
      java.time.format:
        DateTimeFormatter:
          extends: java.lang.Object
          modifiers:
          - public
          - final
          fields:
            chrono:
              name: chrono
              modifiers:
              - private
              type:
                basic: Chronology
                full: java.time.chrono.Chronology
            decimalStyle:
              name: decimalStyle
              modifiers:
              - private
              type:
                basic: DecimalStyle
                full: java.time.format.DecimalStyle
            locale:
              name: locale
              modifiers:
              - private
              type:
                basic: Locale
                full: java.util.Locale
            printerParser:
              name: printerParser
              modifiers:
              - private
              type:
                basic: DateTimeFormatterBuilder.CompositePrinterParser
                full: java.time.format.DateTimeFormatterBuilder$CompositePrinterParser
            resolverFields:
              name: resolverFields
              modifiers:
              - private
              type:
                basic: Set
                full: java.util.Set<java.time.temporal.TemporalField>
            resolverStyle:
              name: resolverStyle
              modifiers:
              - private
              type:
                basic: ResolverStyle
                full: java.time.format.ResolverStyle
            zone:
              name: zone
              modifiers:
              - private
              type:
                basic: ZoneId
                full: java.time.ZoneId
          staticFields:
            BASIC_ISO_DATE:
              name: BASIC_ISO_DATE
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO date formatter that formats or parses a date without\
                \ an\n offset, such as '20111203'.\n \n This returns an immutable\
                \ formatter capable of formatting and parsing\n the ISO-8601 basic\
                \ local date format.\n The format consists of:\n \n Four digits for\
                \ the year.\n  Only years in the range 0000 to 9999 are supported.\n\
                \ Two digits for the month-of-year.\n  This is pre-padded by zero\
                \ to ensure two digits.\n Two digits for the day-of-month.\n  This\
                \ is pre-padded by zero to ensure two digits.\n If the offset is not\
                \ available to format or parse then the format is complete.\n The\
                \ offset ID without colons. If the offset has\n  seconds then they\
                \ will be handled even though this is not part of the ISO-8601 standard.\n\
                \  The offset parsing is lenient, which allows the minutes and seconds\
                \ to be optional.\n  Parsing is case insensitive.\n \n \n As this\
                \ formatter has an optional element, it may be necessary to parse\
                \ using\n parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery<?>...).\n\
                \ \n The returned formatter has a chronology of ISO set to ensure\
                \ dates in\n other calendar systems are correctly converted.\n It\
                \ has no override zone and uses the STRICT resolver style."
            ISO_DATE:
              name: ISO_DATE
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO date formatter that formats or parses a date with the\n\
                \ offset if available, such as '2011-12-03' or '2011-12-03+01:00'.\n\
                \ \n This returns an immutable formatter capable of formatting and\
                \ parsing\n the ISO-8601 extended date format.\n The format consists\
                \ of:\n \n The ISO_LOCAL_DATE\n If the offset is not available then\
                \ the format is complete.\n The offset ID. If the offset has seconds\
                \ then\n  they will be handled even though this is not part of the\
                \ ISO-8601 standard.\n  Parsing is case insensitive.\n \n \n As this\
                \ formatter has an optional element, it may be necessary to parse\
                \ using\n parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery<?>...).\n\
                \ \n The returned formatter has a chronology of ISO set to ensure\
                \ dates in\n other calendar systems are correctly converted.\n It\
                \ has no override zone and uses the STRICT resolver style."
            ISO_DATE_TIME:
              name: ISO_DATE_TIME
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO-like date-time formatter that formats or parses a date-time\
                \ with\n the offset and zone if available, such as '2011-12-03T10:15:30',\n\
                \ '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'.\n\
                \ \n This returns an immutable formatter capable of formatting and\
                \ parsing\n the ISO-8601 extended local or offset date-time format,\
                \ as well as the\n extended non-ISO form specifying the time-zone.\n\
                \ The format consists of:\n \n The ISO_LOCAL_DATE_TIME\n If the offset\
                \ is not available to format or parse then the format is complete.\n\
                \ The offset ID. If the offset has seconds then\n  they will be handled\
                \ even though this is not part of the ISO-8601 standard.\n If the\
                \ zone ID is not available or is a ZoneOffset then the format is complete.\n\
                \ An open square bracket '['.\n The zone ID. This is not part of the\
                \ ISO-8601 standard.\n  Parsing is case sensitive.\n A close square\
                \ bracket ']'.\n \n \n As this formatter has an optional element,\
                \ it may be necessary to parse using\n parseBest(java.lang.CharSequence,\
                \ java.time.temporal.TemporalQuery<?>...).\n \n The returned formatter\
                \ has a chronology of ISO set to ensure dates in\n other calendar\
                \ systems are correctly converted.\n It has no override zone and uses\
                \ the STRICT resolver style."
            ISO_INSTANT:
              name: ISO_INSTANT
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO instant formatter that formats or parses an instant\
                \ in UTC,\n such as '2011-12-03T10:15:30Z'.\n \n This returns an immutable\
                \ formatter capable of formatting and parsing\n the ISO-8601 instant\
                \ format.\n When formatting, the instant will always be suffixed by\
                \ 'Z' to indicate UTC.\n The second-of-minute is always output.\n\
                \ The nano-of-second outputs zero, three, six or nine digits as necessary.\n\
                \ When parsing, the behaviour of DateTimeFormatterBuilder.appendOffsetId()\n\
                \ will be used to parse the offset, converting the instant to UTC\
                \ as necessary.\n The time to at least the seconds field is required.\n\
                \ Fractional seconds from zero to nine are parsed.\n The localized\
                \ decimal style is not used.\n \n This is a special case formatter\
                \ intended to allow a human readable form\n of an Instant. The Instant\
                \ class is designed to\n only represent a point in time and internally\
                \ stores a value in nanoseconds\n from a fixed epoch of 1970-01-01Z.\
                \ As such, an Instant cannot be\n formatted as a date or time without\
                \ providing some form of time-zone.\n This formatter allows the Instant\
                \ to be formatted, by providing\n a suitable conversion using ZoneOffset.UTC.\n\
                \ \n The format consists of:\n \n The ISO_OFFSET_DATE_TIME where the\
                \ instant is converted from\n  ChronoField.INSTANT_SECONDS and ChronoField.NANO_OF_SECOND\n\
                \  using the UTC offset. Parsing is case insensitive.\n \n \n The\
                \ returned formatter has no override chronology or zone.\n It uses\
                \ the STRICT resolver style."
            ISO_LOCAL_DATE:
              name: ISO_LOCAL_DATE
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO date formatter that formats or parses a date without\
                \ an\n offset, such as '2011-12-03'.\n \n This returns an immutable\
                \ formatter capable of formatting and parsing\n the ISO-8601 extended\
                \ local date format.\n The format consists of:\n \n Four digits or\
                \ more for the year.\n Years in the range 0000 to 9999 will be pre-padded\
                \ by zero to ensure four digits.\n Years outside that range will have\
                \ a prefixed positive or negative symbol.\n A dash\n Two digits for\
                \ the month-of-year.\n  This is pre-padded by zero to ensure two digits.\n\
                \ A dash\n Two digits for the day-of-month.\n  This is pre-padded\
                \ by zero to ensure two digits.\n \n \n The returned formatter has\
                \ a chronology of ISO set to ensure dates in\n other calendar systems\
                \ are correctly converted.\n It has no override zone and uses the\
                \ STRICT resolver style."
            ISO_LOCAL_DATE_TIME:
              name: ISO_LOCAL_DATE_TIME
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO date-time formatter that formats or parses a date-time\
                \ without\n an offset, such as '2011-12-03T10:15:30'.\n \n This returns\
                \ an immutable formatter capable of formatting and parsing\n the ISO-8601\
                \ extended offset date-time format.\n The format consists of:\n \n\
                \ The ISO_LOCAL_DATE\n The letter 'T'. Parsing is case insensitive.\n\
                \ The ISO_LOCAL_TIME\n \n \n The returned formatter has a chronology\
                \ of ISO set to ensure dates in\n other calendar systems are correctly\
                \ converted.\n It has no override zone and uses the STRICT resolver\
                \ style."
            ISO_LOCAL_TIME:
              name: ISO_LOCAL_TIME
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO time formatter that formats or parses a time without\
                \ an\n offset, such as '10:15' or '10:15:30'.\n \n This returns an\
                \ immutable formatter capable of formatting and parsing\n the ISO-8601\
                \ extended local time format.\n The format consists of:\n \n Two digits\
                \ for the hour-of-day.\n  This is pre-padded by zero to ensure two\
                \ digits.\n A colon\n Two digits for the minute-of-hour.\n  This is\
                \ pre-padded by zero to ensure two digits.\n If the second-of-minute\
                \ is not available then the format is complete.\n A colon\n Two digits\
                \ for the second-of-minute.\n  This is pre-padded by zero to ensure\
                \ two digits.\n If the nano-of-second is zero or not available then\
                \ the format is complete.\n A decimal point\n One to nine digits for\
                \ the nano-of-second.\n  As many digits will be output as required.\n\
                \ \n \n The returned formatter has no override chronology or zone.\n\
                \ It uses the STRICT resolver style."
            ISO_OFFSET_DATE:
              name: ISO_OFFSET_DATE
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO date formatter that formats or parses a date with an\n\
                \ offset, such as '2011-12-03+01:00'.\n \n This returns an immutable\
                \ formatter capable of formatting and parsing\n the ISO-8601 extended\
                \ offset date format.\n The format consists of:\n \n The ISO_LOCAL_DATE\n\
                \ The offset ID. If the offset has seconds then\n  they will be handled\
                \ even though this is not part of the ISO-8601 standard.\n  Parsing\
                \ is case insensitive.\n \n \n The returned formatter has a chronology\
                \ of ISO set to ensure dates in\n other calendar systems are correctly\
                \ converted.\n It has no override zone and uses the STRICT resolver\
                \ style."
            ISO_OFFSET_DATE_TIME:
              name: ISO_OFFSET_DATE_TIME
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO date-time formatter that formats or parses a date-time\
                \ with an\n offset, such as '2011-12-03T10:15:30+01:00'.\n \n This\
                \ returns an immutable formatter capable of formatting and parsing\n\
                \ the ISO-8601 extended offset date-time format.\n The format consists\
                \ of:\n \n The ISO_LOCAL_DATE_TIME\n The offset ID. If the offset\
                \ has seconds then\n  they will be handled even though this is not\
                \ part of the ISO-8601 standard.\n  The offset parsing is lenient,\
                \ which allows the minutes and seconds to be optional.\n  Parsing\
                \ is case insensitive.\n \n \n The returned formatter has a chronology\
                \ of ISO set to ensure dates in\n other calendar systems are correctly\
                \ converted.\n It has no override zone and uses the STRICT resolver\
                \ style."
            ISO_OFFSET_TIME:
              name: ISO_OFFSET_TIME
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO time formatter that formats or parses a time with an\n\
                \ offset, such as '10:15+01:00' or '10:15:30+01:00'.\n \n This returns\
                \ an immutable formatter capable of formatting and parsing\n the ISO-8601\
                \ extended offset time format.\n The format consists of:\n \n The\
                \ ISO_LOCAL_TIME\n The offset ID. If the offset has seconds then\n\
                \  they will be handled even though this is not part of the ISO-8601\
                \ standard.\n  Parsing is case insensitive.\n \n \n The returned formatter\
                \ has no override chronology or zone.\n It uses the STRICT resolver\
                \ style."
            ISO_ORDINAL_DATE:
              name: ISO_ORDINAL_DATE
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO date formatter that formats or parses the ordinal date\n\
                \ without an offset, such as '2012-337'.\n \n This returns an immutable\
                \ formatter capable of formatting and parsing\n the ISO-8601 extended\
                \ ordinal date format.\n The format consists of:\n \n Four digits\
                \ or more for the year.\n Years in the range 0000 to 9999 will be\
                \ pre-padded by zero to ensure four digits.\n Years outside that range\
                \ will have a prefixed positive or negative symbol.\n A dash\n Three\
                \ digits for the day-of-year.\n  This is pre-padded by zero to ensure\
                \ three digits.\n If the offset is not available to format or parse\
                \ then the format is complete.\n The offset ID. If the offset has\
                \ seconds then\n  they will be handled even though this is not part\
                \ of the ISO-8601 standard.\n  Parsing is case insensitive.\n \n \n\
                \ As this formatter has an optional element, it may be necessary to\
                \ parse using\n parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery<?>...).\n\
                \ \n The returned formatter has a chronology of ISO set to ensure\
                \ dates in\n other calendar systems are correctly converted.\n It\
                \ has no override zone and uses the STRICT resolver style."
            ISO_TIME:
              name: ISO_TIME
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO time formatter that formats or parses a time, with the\n\
                \ offset if available, such as '10:15', '10:15:30' or '10:15:30+01:00'.\n\
                \ \n This returns an immutable formatter capable of formatting and\
                \ parsing\n the ISO-8601 extended offset time format.\n The format\
                \ consists of:\n \n The ISO_LOCAL_TIME\n If the offset is not available\
                \ then the format is complete.\n The offset ID. If the offset has\
                \ seconds then\n  they will be handled even though this is not part\
                \ of the ISO-8601 standard.\n  Parsing is case insensitive.\n \n \n\
                \ As this formatter has an optional element, it may be necessary to\
                \ parse using\n parseBest(java.lang.CharSequence, java.time.temporal.TemporalQuery<?>...).\n\
                \ \n The returned formatter has no override chronology or zone.\n\
                \ It uses the STRICT resolver style."
            ISO_WEEK_DATE:
              name: ISO_WEEK_DATE
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO date formatter that formats or parses the week-based\
                \ date\n without an offset, such as '2012-W48-6'.\n \n This returns\
                \ an immutable formatter capable of formatting and parsing\n the ISO-8601\
                \ extended week-based date format.\n The format consists of:\n \n\
                \ Four digits or more for the week-based-year.\n Years in the range\
                \ 0000 to 9999 will be pre-padded by zero to ensure four digits.\n\
                \ Years outside that range will have a prefixed positive or negative\
                \ symbol.\n A dash\n The letter 'W'. Parsing is case insensitive.\n\
                \ Two digits for the week-of-week-based-year.\n  This is pre-padded\
                \ by zero to ensure three digits.\n A dash\n One digit for the day-of-week.\n\
                \  The value run from Monday (1) to Sunday (7).\n If the offset is\
                \ not available to format or parse then the format is complete.\n\
                \ The offset ID. If the offset has seconds then\n  they will be handled\
                \ even though this is not part of the ISO-8601 standard.\n  Parsing\
                \ is case insensitive.\n \n \n As this formatter has an optional element,\
                \ it may be necessary to parse using\n parseBest(java.lang.CharSequence,\
                \ java.time.temporal.TemporalQuery<?>...).\n \n The returned formatter\
                \ has a chronology of ISO set to ensure dates in\n other calendar\
                \ systems are correctly converted.\n It has no override zone and uses\
                \ the STRICT resolver style."
            ISO_ZONED_DATE_TIME:
              name: ISO_ZONED_DATE_TIME
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The ISO-like date-time formatter that formats or parses a date-time\
                \ with\n offset and zone, such as '2011-12-03T10:15:30+01:00[Europe/Paris]'.\n\
                \ \n This returns an immutable formatter capable of formatting and\
                \ parsing\n a format that extends the ISO-8601 extended offset date-time\
                \ format\n to add the time-zone.\n The section in square brackets\
                \ is not part of the ISO-8601 standard.\n The format consists of:\n\
                \ \n The ISO_OFFSET_DATE_TIME\n If the zone ID is not available or\
                \ is a ZoneOffset then the format is complete.\n An open square bracket\
                \ '['.\n The zone ID. This is not part of the ISO-8601 standard.\n\
                \  Parsing is case sensitive.\n A close square bracket ']'.\n \n \n\
                \ The returned formatter has a chronology of ISO set to ensure dates\
                \ in\n other calendar systems are correctly converted.\n It has no\
                \ override zone and uses the STRICT resolver style."
            PARSED_EXCESS_DAYS:
              name: PARSED_EXCESS_DAYS
              modifiers:
              - private
              - static
              type:
                basic: TemporalQuery
                full: java.time.temporal.TemporalQuery<java.time.Period>
            PARSED_LEAP_SECOND:
              name: PARSED_LEAP_SECOND
              modifiers:
              - private
              - static
              type:
                basic: TemporalQuery
                full: java.time.temporal.TemporalQuery<java.lang.Boolean>
            RFC_1123_DATE_TIME:
              name: RFC_1123_DATE_TIME
              modifiers:
              - public
              - static
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "The RFC-1123 date-time formatter, such as 'Tue, 3 Jun 2008 11:05:30\
                \ GMT'.\n \n This returns an immutable formatter capable of formatting\
                \ and parsing\n most of the RFC-1123 format.\n RFC-1123 updates RFC-822\
                \ changing the year from two digits to four.\n This implementation\
                \ requires a four digit year.\n This implementation also does not\
                \ handle North American or military zone\n names, only 'GMT' and offset\
                \ amounts.\n \n The format consists of:\n \n If the day-of-week is\
                \ not available to format or parse then jump to day-of-month.\n Three\
                \ letter day-of-week in English.\n A comma\n A space\n One or two\
                \ digits for the day-of-month.\n A space\n Three letter month-of-year\
                \ in English.\n A space\n Four digits for the year.\n  Only years\
                \ in the range 0000 to 9999 are supported.\n A space\n Two digits\
                \ for the hour-of-day.\n  This is pre-padded by zero to ensure two\
                \ digits.\n A colon\n Two digits for the minute-of-hour.\n  This is\
                \ pre-padded by zero to ensure two digits.\n If the second-of-minute\
                \ is not available then jump to the next space.\n A colon\n Two digits\
                \ for the second-of-minute.\n  This is pre-padded by zero to ensure\
                \ two digits.\n A space\n The offset ID without colons or seconds.\n\
                \  An offset of zero uses \"GMT\". North American zone names and military\
                \ zone names are not handled.\n \n \n Parsing is case insensitive.\n\
                \ \n The returned formatter has a chronology of ISO set to ensure\
                \ dates in\n other calendar systems are correctly converted.\n It\
                \ has no override zone and uses the SMART resolver style."
          constructors:
          - modifiers:
            - package
            parameters:
            - name: arg0
              type:
                basic: DateTimeFormatterBuilder.CompositePrinterParser
                full: java.time.format.DateTimeFormatterBuilder$CompositePrinterParser
            - name: arg1
              type:
                basic: Locale
                full: java.util.Locale
            - name: arg2
              type:
                basic: DecimalStyle
                full: java.time.format.DecimalStyle
            - name: arg3
              type:
                basic: ResolverStyle
                full: java.time.format.ResolverStyle
            - name: arg4
              type:
                basic: Set
                full: java.util.Set<java.time.temporal.TemporalField>
            - name: arg5
              type:
                basic: Chronology
                full: java.time.chrono.Chronology
            - name: arg6
              type:
                basic: ZoneId
                full: java.time.ZoneId
          methods:
          - name: createError
            modifiers:
            - private
            parameters:
            - name: arg0
              type:
                basic: CharSequence
                full: java.lang.CharSequence
            - name: arg1
              type:
                basic: RuntimeException
                full: java.lang.RuntimeException
            return:
              type:
                basic: DateTimeParseException
                full: java.time.format.DateTimeParseException
          - name: format
            modifiers:
            - public
            parameters:
            - name: temporal
              type:
                basic: TemporalAccessor
                full: java.time.temporal.TemporalAccessor
              notes: the temporal object to format, not null
            return:
              type:
                basic: String
                full: java.lang.String
              notes: the formatted string, not null
            notes: "Formats a date-time object using this formatter.\n \n This formats\
              \ the date-time to a String using the rules of the formatter."
          - name: formatTo
            modifiers:
            - public
            parameters:
            - name: temporal
              type:
                basic: TemporalAccessor
                full: java.time.temporal.TemporalAccessor
              notes: the temporal object to format, not null
            - name: appendable
              type:
                basic: Appendable
                full: java.lang.Appendable
              notes: the appendable to format to, not null
            return:
              type:
                basic: void
                full: void
            notes: "Formats a date-time object to an Appendable using this formatter.\n\
              \ \n This outputs the formatted date-time to the specified destination.\n\
              \ Appendable is a general purpose interface that is implemented by all\n\
              \ key character output classes including StringBuffer, StringBuilder,\n\
              \ PrintStream and Writer.\n \n Although Appendable methods throw an\
              \ IOException, this method does not.\n Instead, any IOException is wrapped\
              \ in a runtime exception."
          - name: getChronology
            modifiers:
            - public
            return:
              type:
                basic: Chronology
                full: java.time.chrono.Chronology
              notes: the override chronology of this formatter, null if no override
            notes: "Gets the overriding chronology to be used during formatting.\n\
              \ \n This returns the override chronology, used to convert dates.\n\
              \ By default, a formatter has no override chronology, returning null.\n\
              \ See withChronology(Chronology) for more details on overriding."
          - name: getDecimalStyle
            modifiers:
            - public
            return:
              type:
                basic: DecimalStyle
                full: java.time.format.DecimalStyle
              notes: the locale of this formatter, not null
            notes: Gets the DecimalStyle to be used during formatting.
          - name: getLocale
            modifiers:
            - public
            return:
              type:
                basic: Locale
                full: java.util.Locale
              notes: the locale of this formatter, not null
            notes: "Gets the locale to be used during formatting.\n \n This is used\
              \ to lookup any part of the formatter needing specific\n localization,\
              \ such as the text or localized pattern."
          - name: getResolverFields
            modifiers:
            - public
            return:
              type:
                basic: Set
                full: java.util.Set<java.time.temporal.TemporalField>
              notes: the immutable set of resolver fields of this formatter, null
                if no fields
            notes: "Gets the resolver fields to use during parsing.\n \n This returns\
              \ the resolver fields, used during the second phase of parsing\n when\
              \ fields are resolved into dates and times.\n By default, a formatter\
              \ has no resolver fields, and thus returns null.\n See withResolverFields(Set)\
              \ for more details."
          - name: getResolverStyle
            modifiers:
            - public
            return:
              type:
                basic: ResolverStyle
                full: java.time.format.ResolverStyle
              notes: the resolver style of this formatter, not null
            notes: "Gets the resolver style to use during parsing.\n \n This returns\
              \ the resolver style, used during the second phase of parsing\n when\
              \ fields are resolved into dates and times.\n By default, a formatter\
              \ has the SMART resolver style.\n See withResolverStyle(ResolverStyle)\
              \ for more details."
          - name: getZone
            modifiers:
            - public
            return:
              type:
                basic: ZoneId
                full: java.time.ZoneId
              notes: the override zone of this formatter, null if no override
            notes: "Gets the overriding zone to be used during formatting.\n \n This\
              \ returns the override zone, used to convert instants.\n By default,\
              \ a formatter has no override zone, returning null.\n See withZone(ZoneId)\
              \ for more details on overriding."
          - name: localizedBy
            modifiers:
            - public
            parameters:
            - name: locale
              type:
                basic: Locale
                full: java.util.Locale
              notes: the locale, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: "a formatter based on this formatter with localized values of\n\
                \      the calendar, decimal style and/or timezone, that supersede\
                \ values in this\n      formatter."
            notes: "Returns a copy of this formatter with localized values of the\
              \ locale,\n calendar, region, decimal style and/or timezone, that supersede\
              \ values in\n this formatter.\n \n This is used to lookup any part of\
              \ the formatter needing specific\n localization, such as the text or\
              \ localized pattern. If the locale contains the\n \"ca\" (calendar),\
              \ \"nu\" (numbering system), \"rg\" (region override), and/or\n \"tz\"\
              \ (timezone)\n Unicode extensions,\n the chronology, numbering system\
              \ and/or the zone are overridden. If both \"ca\"\n and \"rg\" are specified,\
              \ the chronology from the \"ca\" extension supersedes the\n implicit\
              \ one from the \"rg\" extension. Same is true for the \"nu\" extension.\n\
              \ \n Unlike the withLocale method, the call to this method may\n produce\
              \ a different formatter depending on the order of method chaining with\n\
              \ other withXXXX() methods.\n \n This instance is immutable and unaffected\
              \ by this method call."
          - name: parse
            modifiers:
            - public
            parameters:
            - name: text
              type:
                basic: CharSequence
                full: java.lang.CharSequence
              notes: the text to parse, not null
            return:
              type:
                basic: TemporalAccessor
                full: java.time.temporal.TemporalAccessor
              notes: the parsed temporal object, not null
            notes: "Fully parses the text producing a temporal object.\n \n This parses\
              \ the entire text producing a temporal object.\n It is typically more\
              \ useful to use parse(CharSequence, TemporalQuery).\n The result of\
              \ this method is TemporalAccessor which has been resolved,\n applying\
              \ basic validation checks to help ensure a valid date-time.\n \n If\
              \ the parse completes without reading the entire length of the text,\n\
              \ or a problem occurs during parsing or merging, then an exception is\
              \ thrown."
          - name: parse
            modifiers:
            - public
            parameters:
            - name: text
              type:
                basic: CharSequence
                full: java.lang.CharSequence
              notes: the text to parse, not null
            - name: position
              type:
                basic: ParsePosition
                full: java.text.ParsePosition
              notes: "the position to parse from, updated with length parsed\n  and\
                \ the index of any error, not null"
            return:
              type:
                basic: TemporalAccessor
                full: java.time.temporal.TemporalAccessor
              notes: the parsed temporal object, not null
            notes: "Parses the text using this formatter, providing control over the\
              \ text position.\n \n This parses the text without requiring the parse\
              \ to start from the beginning\n of the string or finish at the end.\n\
              \ The result of this method is TemporalAccessor which has been resolved,\n\
              \ applying basic validation checks to help ensure a valid date-time.\n\
              \ \n The text will be parsed from the specified start ParsePosition.\n\
              \ The entire length of the text does not have to be parsed, the ParsePosition\n\
              \ will be updated with the index at the end of parsing.\n \n The operation\
              \ of this method is slightly different to similar methods using\n ParsePosition\
              \ on java.text.Format. That class will return\n errors using the error\
              \ index on the ParsePosition. By contrast, this\n method will throw\
              \ a DateTimeParseException if an error occurs, with\n the exception\
              \ containing the error index.\n This change in behavior is necessary\
              \ due to the increased complexity of\n parsing and resolving dates/times\
              \ in this API.\n \n If the formatter parses the same field more than\
              \ once with different values,\n the result will be an error."
          - name: parse
            modifiers:
            - public
            parameters:
            - name: text
              type:
                basic: CharSequence
                full: java.lang.CharSequence
              notes: the text to parse, not null
            - name: query
              type:
                basic: TemporalQuery
                full: java.time.temporal.TemporalQuery<T>
              notes: the query defining the type to parse to, not null
            return:
              type:
                basic: T
                full: T
              notes: the parsed date-time, not null
            notes: "Fully parses the text producing an object of the specified type.\n\
              \ \n Most applications should use this method for parsing.\n It parses\
              \ the entire text to produce the required date-time.\n The query is\
              \ typically a method reference to a from(TemporalAccessor) method.\n\
              \ For example:\n \n  LocalDateTime dt = parser.parse(str, LocalDateTime::from);\n\
              \ \n If the parse completes without reading the entire length of the\
              \ text,\n or a problem occurs during parsing or merging, then an exception\
              \ is thrown."
          - name: parseBest
            modifiers:
            - public
            parameters:
            - name: arg0
              type:
                basic: CharSequence
                full: java.lang.CharSequence
            - name: arg1
              type:
                basic: TemporalQuery
                full: java.time.temporal.TemporalQuery<?>[]
            return:
              type:
                basic: TemporalAccessor
                full: java.time.temporal.TemporalAccessor
          - name: parseResolved0
            modifiers:
            - private
            parameters:
            - name: arg0
              type:
                basic: CharSequence
                full: java.lang.CharSequence
            - name: arg1
              type:
                basic: ParsePosition
                full: java.text.ParsePosition
            return:
              type:
                basic: TemporalAccessor
                full: java.time.temporal.TemporalAccessor
          - name: parseUnresolved
            modifiers:
            - public
            parameters:
            - name: text
              type:
                basic: CharSequence
                full: java.lang.CharSequence
              notes: the text to parse, not null
            - name: position
              type:
                basic: ParsePosition
                full: java.text.ParsePosition
              notes: "the position to parse from, updated with length parsed\n  and\
                \ the index of any error, not null"
            return:
              type:
                basic: TemporalAccessor
                full: java.time.temporal.TemporalAccessor
              notes: the parsed text, null if the parse results in an error
            notes: "Parses the text using this formatter, without resolving the result,\
              \ intended\n for advanced use cases.\n \n Parsing is implemented as\
              \ a two-phase operation.\n First, the text is parsed using the layout\
              \ defined by the formatter, producing\n a Map of field to value, a ZoneId\
              \ and a Chronology.\n Second, the parsed data is resolved, by validating,\
              \ combining and\n simplifying the various fields into more useful ones.\n\
              \ This method performs the parsing stage but not the resolving stage.\n\
              \ \n The result of this method is TemporalAccessor which represents\
              \ the\n data as seen in the input. Values are not validated, thus parsing\
              \ a date string\n of '2012-00-65' would result in a temporal with three\
              \ fields - year of '2012',\n month of '0' and day-of-month of '65'.\n\
              \ \n The text will be parsed from the specified start ParsePosition.\n\
              \ The entire length of the text does not have to be parsed, the ParsePosition\n\
              \ will be updated with the index at the end of parsing.\n \n Errors\
              \ are returned using the error index field of the ParsePosition\n instead\
              \ of DateTimeParseException.\n The returned error index will be set\
              \ to an index indicative of the error.\n Callers must check for errors\
              \ before using the result.\n \n If the formatter parses the same field\
              \ more than once with different values,\n the result will be an error.\n\
              \ \n This method is intended for advanced use cases that need access\
              \ to the\n internal state during parsing. Typical application code should\
              \ use\n parse(CharSequence, TemporalQuery) or the parse method on the\
              \ target type."
          - name: parseUnresolved0
            modifiers:
            - private
            parameters:
            - name: arg0
              type:
                basic: CharSequence
                full: java.lang.CharSequence
            - name: arg1
              type:
                basic: ParsePosition
                full: java.text.ParsePosition
            return:
              type:
                basic: DateTimeParseContext
                full: java.time.format.DateTimeParseContext
          - name: toFormat
            modifiers:
            - public
            return:
              type:
                basic: Format
                full: java.text.Format
              notes: this formatter as a classic format instance, not null
            notes: "Returns this formatter as a java.text.Format instance.\n \n The\
              \ returned Format instance will format any TemporalAccessor\n and parses\
              \ to a resolved TemporalAccessor.\n \n Exceptions will follow the definitions\
              \ of Format, see those methods\n for details about IllegalArgumentException\
              \ during formatting and\n ParseException or null during parsing.\n The\
              \ format does not support attributing of the returned format string."
          - name: toFormat
            modifiers:
            - public
            parameters:
            - name: parseQuery
              type:
                basic: TemporalQuery
                full: java.time.temporal.TemporalQuery<?>
              notes: the query defining the type to parse to, not null
            return:
              type:
                basic: Format
                full: java.text.Format
              notes: this formatter as a classic format instance, not null
            notes: "Returns this formatter as a java.text.Format instance that will\n\
              \ parse using the specified query.\n \n The returned Format instance\
              \ will format any TemporalAccessor\n and parses to the type specified.\n\
              \ The type must be one that is supported by parse(java.lang.CharSequence).\n\
              \ \n Exceptions will follow the definitions of Format, see those methods\n\
              \ for details about IllegalArgumentException during formatting and\n\
              \ ParseException or null during parsing.\n The format does not support\
              \ attributing of the returned format string."
          - name: toPrinterParser
            modifiers:
            - package
            parameters:
            - name: arg0
              type:
                basic: boolean
                full: boolean
            return:
              type:
                basic: DateTimeFormatterBuilder.CompositePrinterParser
                full: java.time.format.DateTimeFormatterBuilder$CompositePrinterParser
          - name: toString
            modifiers:
            - public
            return:
              type:
                basic: String
                full: java.lang.String
          - name: withChronology
            modifiers:
            - public
            parameters:
            - name: chrono
              type:
                basic: Chronology
                full: java.time.chrono.Chronology
              notes: the new chronology, null if no override
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: a formatter based on this formatter with the requested override
                chronology, not null
            notes: "Returns a copy of this formatter with a new override chronology.\n\
              \ \n This returns a formatter with similar state to this formatter but\n\
              \ with the override chronology set.\n By default, a formatter has no\
              \ override chronology, returning null.\n \n If an override is added,\
              \ then any date that is formatted or parsed will be affected.\n \n When\
              \ formatting, if the temporal object contains a date, then it will\n\
              \ be converted to a date in the override chronology.\n Whether the temporal\
              \ contains a date is determined by querying the\n EPOCH_DAY field.\n\
              \ Any time or zone will be retained unaltered unless overridden.\n \n\
              \ If the temporal object does not contain a date, but does contain one\n\
              \ or more ChronoField date fields, then a DateTimeException\n is thrown.\
              \ In all other cases, the override chronology is added to the temporal,\n\
              \ replacing any previous chronology, but without changing the date/time.\n\
              \ \n When parsing, there are two distinct cases to consider.\n If a\
              \ chronology has been parsed directly from the text, perhaps because\n\
              \ DateTimeFormatterBuilder.appendChronologyId() was used, then\n this\
              \ override chronology has no effect.\n If no zone has been parsed, then\
              \ this override chronology will be used\n to interpret the ChronoField\
              \ values into a date according to the\n date resolving rules of the\
              \ chronology.\n \n This instance is immutable and unaffected by this\
              \ method call."
          - name: withDecimalStyle
            modifiers:
            - public
            parameters:
            - name: decimalStyle
              type:
                basic: DecimalStyle
                full: java.time.format.DecimalStyle
              notes: the new DecimalStyle, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: a formatter based on this formatter with the requested DecimalStyle,
                not null
            notes: "Returns a copy of this formatter with a new DecimalStyle.\n \n\
              \ This instance is immutable and unaffected by this method call."
          - name: withLocale
            modifiers:
            - public
            parameters:
            - name: locale
              type:
                basic: Locale
                full: java.util.Locale
              notes: the new locale, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: a formatter based on this formatter with the requested locale,
                not null
            notes: "Returns a copy of this formatter with a new locale.\n \n This\
              \ is used to lookup any part of the formatter needing specific\n localization,\
              \ such as the text or localized pattern.\n \n The locale is stored as\
              \ passed in, without further processing.\n If the locale has \n Unicode\
              \ extensions, they may be used later in text\n processing. To set the\
              \ chronology, time-zone and decimal style from\n unicode extensions,\
              \ see localizedBy().\n \n This instance is immutable and unaffected\
              \ by this method call."
          - name: withResolverFields
            modifiers:
            - public
            parameters:
            - name: arg0
              type:
                basic: TemporalField
                full: java.time.temporal.TemporalField[]
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
          - name: withResolverFields
            modifiers:
            - public
            parameters:
            - name: resolverFields
              type:
                basic: Set
                full: java.util.Set<java.time.temporal.TemporalField>
              notes: the new set of resolver fields, null if no fields
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: a formatter based on this formatter with the requested resolver
                style, not null
            notes: "Returns a copy of this formatter with a new set of resolver fields.\n\
              \ \n This returns a formatter with similar state to this formatter but\
              \ with\n the resolver fields set. By default, a formatter has no resolver\
              \ fields.\n \n Changing the resolver fields only has an effect during\
              \ parsing.\n Parsing a text string occurs in two phases.\n Phase 1 is\
              \ a basic text parse according to the fields added to the builder.\n\
              \ Phase 2 resolves the parsed field-value pairs into date and/or time\
              \ objects.\n The resolver fields are used to filter the field-value\
              \ pairs between phase 1 and 2.\n \n This can be used to select between\
              \ two or more ways that a date or time might\n be resolved. For example,\
              \ if the formatter consists of year, month, day-of-month\n and day-of-year,\
              \ then there are two ways to resolve a date.\n Calling this method with\
              \ the arguments YEAR and\n DAY_OF_YEAR will ensure that the date is\n\
              \ resolved using the year and day-of-year, effectively meaning that\
              \ the month\n and day-of-month are ignored during the resolving phase.\n\
              \ \n In a similar manner, this method can be used to ignore secondary\
              \ fields that\n would otherwise be cross-checked. For example, if the\
              \ formatter consists of year,\n month, day-of-month and day-of-week,\
              \ then there is only one way to resolve a\n date, but the parsed value\
              \ for day-of-week will be cross-checked against the\n resolved date.\
              \ Calling this method with the arguments YEAR,\n MONTH_OF_YEAR and\n\
              \ DAY_OF_MONTH will ensure that the date is\n resolved correctly, but\
              \ without any cross-check for the day-of-week.\n \n In implementation\
              \ terms, this method behaves as follows. The result of the\n parsing\
              \ phase can be considered to be a map of field to value. The behavior\n\
              \ of this method is to cause that map to be filtered between phase 1\
              \ and 2,\n removing all fields other than those specified as arguments\
              \ to this method.\n \n This instance is immutable and unaffected by\
              \ this method call."
          - name: withResolverStyle
            modifiers:
            - public
            parameters:
            - name: resolverStyle
              type:
                basic: ResolverStyle
                full: java.time.format.ResolverStyle
              notes: the new resolver style, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: a formatter based on this formatter with the requested resolver
                style, not null
            notes: "Returns a copy of this formatter with a new resolver style.\n\
              \ \n This returns a formatter with similar state to this formatter but\n\
              \ with the resolver style set. By default, a formatter has the\n SMART\
              \ resolver style.\n \n Changing the resolver style only has an effect\
              \ during parsing.\n Parsing a text string occurs in two phases.\n Phase\
              \ 1 is a basic text parse according to the fields added to the builder.\n\
              \ Phase 2 resolves the parsed field-value pairs into date and/or time\
              \ objects.\n The resolver style is used to control how phase 2, resolving,\
              \ happens.\n See ResolverStyle for more information on the options available.\n\
              \ \n This instance is immutable and unaffected by this method call."
          - name: withZone
            modifiers:
            - public
            parameters:
            - name: zone
              type:
                basic: ZoneId
                full: java.time.ZoneId
              notes: the new override zone, null if no override
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: a formatter based on this formatter with the requested override
                zone, not null
            notes: "Returns a copy of this formatter with a new override zone.\n \n\
              \ This returns a formatter with similar state to this formatter but\n\
              \ with the override zone set.\n By default, a formatter has no override\
              \ zone, returning null.\n \n If an override is added, then any instant\
              \ that is formatted or parsed will be affected.\n \n When formatting,\
              \ if the temporal object contains an instant, then it will\n be converted\
              \ to a zoned date-time using the override zone.\n Whether the temporal\
              \ is an instant is determined by querying the\n INSTANT_SECONDS field.\n\
              \ If the input has a chronology then it will be retained unless overridden.\n\
              \ If the input does not have a chronology, such as Instant, then\n the\
              \ ISO chronology will be used.\n \n If the temporal object does not\
              \ contain an instant, but does contain\n an offset then an additional\
              \ check is made. If the normalized override\n zone is an offset that\
              \ differs from the offset of the temporal, then\n a DateTimeException\
              \ is thrown. In all other cases, the override\n zone is added to the\
              \ temporal, replacing any previous zone, but without\n changing the\
              \ date/time.\n \n When parsing, there are two distinct cases to consider.\n\
              \ If a zone has been parsed directly from the text, perhaps because\n\
              \ DateTimeFormatterBuilder.appendZoneId() was used, then\n this override\
              \ zone has no effect.\n If no zone has been parsed, then this override\
              \ zone will be included in\n the result of the parse where it can be\
              \ used to build instants and date-times.\n \n This instance is immutable\
              \ and unaffected by this method call."
          staticMethods:
          - name: lambda$static$0
            modifiers:
            - private
            - static
            parameters:
            - name: arg0
              type:
                basic: TemporalAccessor
                full: java.time.temporal.TemporalAccessor
            return:
              type:
                basic: Period
                full: java.time.Period
          - name: lambda$static$1
            modifiers:
            - private
            - static
            parameters:
            - name: arg0
              type:
                basic: TemporalAccessor
                full: java.time.temporal.TemporalAccessor
            return:
              type:
                basic: Boolean
                full: java.lang.Boolean
          - name: ofLocalizedDate
            modifiers:
            - public
            - static
            parameters:
            - name: dateStyle
              type:
                basic: FormatStyle
                full: java.time.format.FormatStyle
              notes: the formatter style to obtain, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: the date formatter, not null
            notes: "Returns a locale specific date format for the ISO chronology.\n\
              \ \n This returns a formatter that will format or parse a date.\n The\
              \ exact format pattern used varies by locale.\n \n The locale is determined\
              \ from the formatter. The formatter returned directly by\n this method\
              \ will use the default FORMAT locale.\n The locale can be controlled\
              \ using withLocale(Locale)\n on the result of this method.\n \n Note\
              \ that the localized pattern is looked up lazily.\n This DateTimeFormatter\
              \ holds the style required and the locale,\n looking up the pattern\
              \ required on demand.\n \n The returned formatter has a chronology of\
              \ ISO set to ensure dates in\n other calendar systems are correctly\
              \ converted.\n It has no override zone and uses the SMART resolver style."
          - name: ofLocalizedDateTime
            modifiers:
            - public
            - static
            parameters:
            - name: dateTimeStyle
              type:
                basic: FormatStyle
                full: java.time.format.FormatStyle
              notes: the formatter style to obtain, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: the date-time formatter, not null
            notes: "Returns a locale specific date-time formatter for the ISO chronology.\n\
              \ \n This returns a formatter that will format or parse a date-time.\n\
              \ The exact format pattern used varies by locale.\n \n The locale is\
              \ determined from the formatter. The formatter returned directly by\n\
              \ this method will use the default FORMAT locale.\n The locale can be\
              \ controlled using withLocale(Locale)\n on the result of this method.\n\
              \ \n Note that the localized pattern is looked up lazily.\n This DateTimeFormatter\
              \ holds the style required and the locale,\n looking up the pattern\
              \ required on demand.\n \n The returned formatter has a chronology of\
              \ ISO set to ensure dates in\n other calendar systems are correctly\
              \ converted.\n It has no override zone and uses the SMART resolver style.\n\
              \ The FULL and LONG styles typically require a time-zone.\n When formatting\
              \ using these styles, a ZoneId must be available,\n either by using\
              \ ZonedDateTime or withZone(java.time.ZoneId)."
          - name: ofLocalizedDateTime
            modifiers:
            - public
            - static
            parameters:
            - name: dateStyle
              type:
                basic: FormatStyle
                full: java.time.format.FormatStyle
              notes: the date formatter style to obtain, not null
            - name: timeStyle
              type:
                basic: FormatStyle
                full: java.time.format.FormatStyle
              notes: the time formatter style to obtain, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: the date, time or date-time formatter, not null
            notes: "Returns a locale specific date and time format for the ISO chronology.\n\
              \ \n This returns a formatter that will format or parse a date-time.\n\
              \ The exact format pattern used varies by locale.\n \n The locale is\
              \ determined from the formatter. The formatter returned directly by\n\
              \ this method will use the default FORMAT locale.\n The locale can be\
              \ controlled using withLocale(Locale)\n on the result of this method.\n\
              \ \n Note that the localized pattern is looked up lazily.\n This DateTimeFormatter\
              \ holds the style required and the locale,\n looking up the pattern\
              \ required on demand.\n \n The returned formatter has a chronology of\
              \ ISO set to ensure dates in\n other calendar systems are correctly\
              \ converted.\n It has no override zone and uses the SMART resolver style.\n\
              \ The FULL and LONG styles typically require a time-zone.\n When formatting\
              \ using these styles, a ZoneId must be available,\n either by using\
              \ ZonedDateTime or withZone(java.time.ZoneId)."
          - name: ofLocalizedTime
            modifiers:
            - public
            - static
            parameters:
            - name: timeStyle
              type:
                basic: FormatStyle
                full: java.time.format.FormatStyle
              notes: the formatter style to obtain, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: the time formatter, not null
            notes: "Returns a locale specific time format for the ISO chronology.\n\
              \ \n This returns a formatter that will format or parse a time.\n The\
              \ exact format pattern used varies by locale.\n \n The locale is determined\
              \ from the formatter. The formatter returned directly by\n this method\
              \ will use the default FORMAT locale.\n The locale can be controlled\
              \ using withLocale(Locale)\n on the result of this method.\n \n Note\
              \ that the localized pattern is looked up lazily.\n This DateTimeFormatter\
              \ holds the style required and the locale,\n looking up the pattern\
              \ required on demand.\n \n The returned formatter has a chronology of\
              \ ISO set to ensure dates in\n other calendar systems are correctly\
              \ converted.\n It has no override zone and uses the SMART resolver style.\n\
              \ The FULL and LONG styles typically require a time-zone.\n When formatting\
              \ using these styles, a ZoneId must be available,\n either by using\
              \ ZonedDateTime or withZone(java.time.ZoneId)."
          - name: ofPattern
            modifiers:
            - public
            - static
            parameters:
            - name: pattern
              type:
                basic: String
                full: java.lang.String
              notes: the pattern to use, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: the formatter based on the pattern, not null
            notes: "Creates a formatter using the specified pattern.\n \n This method\
              \ will create a formatter based on a simple\n pattern of letters and\
              \ symbols\n as described in the class documentation.\n For example,\
              \ d MMM uuuu will format 2011-12-03 as '3 Dec 2011'.\n \n The formatter\
              \ will use the default FORMAT locale.\n This can be changed using withLocale(Locale)\
              \ on the returned formatter.\n Alternatively use the ofPattern(String,\
              \ Locale) variant of this method.\n \n The returned formatter has no\
              \ override chronology or zone.\n It uses SMART resolver style."
          - name: ofPattern
            modifiers:
            - public
            - static
            parameters:
            - name: pattern
              type:
                basic: String
                full: java.lang.String
              notes: the pattern to use, not null
            - name: locale
              type:
                basic: Locale
                full: java.util.Locale
              notes: the locale to use, not null
            return:
              type:
                basic: DateTimeFormatter
                full: java.time.format.DateTimeFormatter
              notes: the formatter based on the pattern, not null
            notes: "Creates a formatter using the specified pattern and locale.\n\
              \ \n This method will create a formatter based on a simple\n pattern\
              \ of letters and symbols\n as described in the class documentation.\n\
              \ For example, d MMM uuuu will format 2011-12-03 as '3 Dec 2011'.\n\
              \ \n The formatter will use the specified locale.\n This can be changed\
              \ using withLocale(Locale) on the returned formatter.\n \n The returned\
              \ formatter has no override chronology or zone.\n It uses SMART resolver\
              \ style."
          - name: parsedExcessDays
            modifiers:
            - public
            - final
            - static
            return:
              type:
                basic: TemporalQuery
                full: java.time.temporal.TemporalQuery<java.time.Period>
              notes: a query that provides access to the excess days that were parsed
            notes: "A query that provides access to the excess days that were parsed.\n\
              \ \n This returns a singleton query that provides\n access to additional\
              \ information from the parse. The query always returns\n a non-null\
              \ period, with a zero period returned instead of null.\n \n There are\
              \ two situations where this query may return a non-zero period.\n \n\
              \ If the ResolverStyle is LENIENT and a time is parsed\n  without a\
              \ date, then the complete result of the parse consists of a\n  LocalTime\
              \ and an excess Period in days.\n\n If the ResolverStyle is SMART and\
              \ a time is parsed\n  without a date where the time is 24:00:00, then\
              \ the complete result of\n  the parse consists of a LocalTime of 00:00:00\
              \ and an excess\n  Period of one day.\n \n \n In both cases, if a complete\
              \ ChronoLocalDateTime or Instant\n is parsed, then the excess days are\
              \ added to the date part.\n As a result, this query will return a zero\
              \ period.\n \n The SMART behaviour handles the common \"end of day\"\
              \ 24:00 value.\n Processing in LENIENT mode also produces the same result:\n\
              \ \n  Text to parse        Parsed object                         Excess\
              \ days\n  \"2012-12-03T00:00\"   LocalDateTime.of(2012, 12, 3, 0, 0)\
              \   ZERO\n  \"2012-12-03T24:00\"   LocalDateTime.of(2012, 12, 4, 0,\
              \ 0)   ZERO\n  \"00:00\"              LocalTime.of(0, 0)           \
              \         ZERO\n  \"24:00\"              LocalTime.of(0, 0)        \
              \            Period.ofDays(1)\n \n The query can be used as follows:\n\
              \ \n  TemporalAccessor parsed = formatter.parse(str);\n  LocalTime time\
              \ = parsed.query(LocalTime::from);\n  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());"
          - name: parsedLeapSecond
            modifiers:
            - public
            - final
            - static
            return:
              type:
                basic: TemporalQuery
                full: java.time.temporal.TemporalQuery<java.lang.Boolean>
              notes: a query that provides access to whether a leap-second was parsed
            notes: "A query that provides access to whether a leap-second was parsed.\n\
              \ \n This returns a singleton query that provides\n access to additional\
              \ information from the parse. The query always returns\n a non-null\
              \ boolean, true if parsing saw a leap-second, false if not.\n \n Instant\
              \ parsing handles the special \"leap second\" time of '23:59:60'.\n\
              \ Leap seconds occur at '23:59:60' in the UTC time-zone, but at other\n\
              \ local times in different time-zones. To avoid this potential ambiguity,\n\
              \ the handling of leap-seconds is limited to\n DateTimeFormatterBuilder.appendInstant(),\
              \ as that method\n always parses the instant with the UTC zone offset.\n\
              \ \n If the time '23:59:60' is received, then a simple conversion is\
              \ applied,\n replacing the second-of-minute of 60 with 59. This query\
              \ can be used\n on the parse result to determine if the leap-second\
              \ adjustment was made.\n The query will return true if it did adjust\
              \ to remove the\n leap-second, and false if not. Note that applying\
              \ a leap-second\n smoothing mechanism, such as UTC-SLS, is the responsibility\
              \ of the\n application, as follows:\n \n  TemporalAccessor parsed =\
              \ formatter.parse(str);\n  Instant instant = parsed.query(Instant::from);\n\
              \  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {\n    //\
              \ validate leap-second is correct and apply correct smoothing\n  }"
