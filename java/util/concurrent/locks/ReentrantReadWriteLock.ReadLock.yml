version: '1.1'
languages:
  java:
    packages:
      java.util.concurrent.locks:
        ReentrantReadWriteLock.ReadLock:
          extends: java.lang.Object
          modifiers:
          - public
          notes: The lock returned by method ReentrantReadWriteLock.readLock().
          fields:
            sync:
              name: sync
              modifiers:
              - private
              type:
                basic: ReentrantReadWriteLock.Sync
                full: java.util.concurrent.locks.ReentrantReadWriteLock$Sync
          staticFields:
            serialVersionUID:
              name: serialVersionUID
              modifiers:
              - private
              - static
              type:
                basic: long
                full: long
          constructors:
          - modifiers:
            - protected
            parameters:
            - name: lock
              type:
                basic: ReentrantReadWriteLock
                full: java.util.concurrent.locks.ReentrantReadWriteLock
              notes: the outer lock object
            notes: Constructor for use by subclasses.
          methods:
          - name: lock
            modifiers:
            - public
            return:
              type:
                basic: void
                full: void
            notes: "Acquires the read lock.\n\n Acquires the read lock if the write\
              \ lock is not held by\n another thread and returns immediately.\n\n\
              \ If the write lock is held by another thread then\n the current thread\
              \ becomes disabled for thread scheduling\n purposes and lies dormant\
              \ until the read lock has been acquired."
          - name: lockInterruptibly
            modifiers:
            - public
            return:
              type:
                basic: void
                full: void
            notes: "Acquires the read lock unless the current thread is\n interrupted.\n\
              \n Acquires the read lock if the write lock is not held\n by another\
              \ thread and returns immediately.\n\n If the write lock is held by another\
              \ thread then the\n current thread becomes disabled for thread scheduling\n\
              \ purposes and lies dormant until one of two things happens:\n\n \n\n\
              \ The read lock is acquired by the current thread; or\n\n Some other\
              \ thread interrupts\n the current thread.\n\n \n\n If the current thread:\n\
              \n \n\n has its interrupted status set on entry to this method; or\n\
              \n is interrupted while\n acquiring the read lock,\n\n \n\n then InterruptedException\
              \ is thrown and the current\n thread's interrupted status is cleared.\n\
              \n In this implementation, as this method is an explicit\n interruption\
              \ point, preference is given to responding to\n the interrupt over normal\
              \ or reentrant acquisition of the\n lock."
          - name: newCondition
            modifiers:
            - public
            return:
              type:
                basic: Condition
                full: java.util.concurrent.locks.Condition
              notes: A new Condition instance for this Lock instance
            notes: "Throws UnsupportedOperationException because\n ReadLocks do not\
              \ support conditions."
          - name: toString
            modifiers:
            - public
            return:
              type:
                basic: String
                full: java.lang.String
          - name: tryLock
            modifiers:
            - public
            return:
              type:
                basic: boolean
                full: boolean
              notes: true if the read lock was acquired
            notes: "Acquires the read lock only if the write lock is not held by\n\
              \ another thread at the time of invocation.\n\n Acquires the read lock\
              \ if the write lock is not held by\n another thread and returns immediately\
              \ with the value\n true. Even when this lock has been set to use a\n\
              \ fair ordering policy, a call to tryLock()\n will immediately acquire\
              \ the read lock if it is\n available, whether or not other threads are\
              \ currently\n waiting for the read lock.  This &quot;barging&quot; behavior\n\
              \ can be useful in certain circumstances, even though it\n breaks fairness.\
              \ If you want to honor the fairness setting\n for this lock, then use\
              \ tryLock(0, TimeUnit.SECONDS) which is almost equivalent\n (it also\
              \ detects interruption).\n\n If the write lock is held by another thread\
              \ then\n this method will return immediately with the value\n false."
          - name: tryLock
            modifiers:
            - public
            parameters:
            - name: timeout
              type:
                basic: long
                full: long
              notes: the time to wait for the read lock
            - name: unit
              type:
                basic: TimeUnit
                full: java.util.concurrent.TimeUnit
              notes: the time unit of the timeout argument
            return:
              type:
                basic: boolean
                full: boolean
              notes: true if the read lock was acquired
            notes: "Acquires the read lock if the write lock is not held by\n another\
              \ thread within the given waiting time and the\n current thread has\
              \ not been interrupted.\n\n Acquires the read lock if the write lock\
              \ is not held by\n another thread and returns immediately with the value\n\
              \ true. If this lock has been set to use a fair\n ordering policy then\
              \ an available lock will not be\n acquired if any other threads are\
              \ waiting for the\n lock. This is in contrast to the tryLock()\n method.\
              \ If you want a timed tryLock that does\n permit barging on a fair lock\
              \ then combine the timed and\n un-timed forms together:\n\n  <code>\n\
              \ if (lock.tryLock() ||\n     lock.tryLock(timeout, unit)) {\n   ...\n\
              \ }</code>\n\n If the write lock is held by another thread then the\n\
              \ current thread becomes disabled for thread scheduling\n purposes and\
              \ lies dormant until one of three things happens:\n\n \n\n The read\
              \ lock is acquired by the current thread; or\n\n Some other thread interrupts\n\
              \ the current thread; or\n\n The specified waiting time elapses.\n\n\
              \ \n\n If the read lock is acquired then the value true is\n returned.\n\
              \n If the current thread:\n\n \n\n has its interrupted status set on\
              \ entry to this method; or\n\n is interrupted while\n acquiring the\
              \ read lock,\n\n  then InterruptedException is thrown and the\n current\
              \ thread's interrupted status is cleared.\n\n If the specified waiting\
              \ time elapses then the value\n false is returned.  If the time is less\
              \ than or\n equal to zero, the method will not wait at all.\n\n In this\
              \ implementation, as this method is an explicit\n interruption point,\
              \ preference is given to responding to\n the interrupt over normal or\
              \ reentrant acquisition of the\n lock, and over reporting the elapse\
              \ of the waiting time."
          - name: unlock
            modifiers:
            - public
            return:
              type:
                basic: void
                full: void
            notes: "Attempts to release this lock.\n\n If the number of readers is\
              \ now zero then the lock\n is made available for write lock attempts.\
              \ If the current\n thread does not hold this lock then IllegalMonitorStateException\
              \ is thrown."
